/**
 * @brief Comprehensive help system for Cube class methods and usage.
 * 
 * Provides detailed information about all available methods, their parameters,
 * return types, usage examples, and categorization. Similar to Linux man pages
 * but specifically designed for the Cube class API.
 * 
 * @param topic Optional specific topic or method name to get help for.
 *              If empty, shows general help and available categories.
 */
void help(const std::string& topic = "") const {
    if (topic.empty()) {
        showGeneralHelp();
        return;
    }
    
    // Convert topic to lowercase for case-insensitive matching
    std::string lower_topic = topic;
    std::transform(lower_topic.begin(), lower_topic.end(), lower_topic.begin(), ::tolower);
    
    // Handle category help
    if (lower_topic == "constructors" || lower_topic == "creation") {
        showConstructorHelp();
    } else if (lower_topic == "basic" || lower_topic == "geometry") {
        showBasicOperationsHelp();
    } else if (lower_topic == "subdivision" || lower_topic == "subdivide") {
        showSubdivisionHelp();
    } else if (lower_topic == "coordinates" || lower_topic == "coords") {
        showCoordinateHelp();
    } else if (lower_topic == "subcells" || lower_topic == "subcell") {
        showSubcellHelp();
    } else if (lower_topic == "vertices" || lower_topic == "vertex") {
        showVertexHelp();
    } else if (lower_topic == "planes" || lower_topic == "plane") {
        showPlaneHelp();
    } else if (lower_topic == "patterns" || lower_topic == "pattern") {
        showPatternHelp();
    } else if (lower_topic == "facets" || lower_topic == "faces" || lower_topic == "triangles") {
        showFacetHelp();
    }
    // Handle specific method help
    else if (lower_topic == "facecount") {
        showMethodHelp("faceCount");
    } else if (lower_topic == "center") {
        showMethodHelp("center");
    } else if (lower_topic == "translate") {
        showMethodHelp("translate");
    } else if (lower_topic == "scale") {
        showMethodHelp("scale");
    } else if (lower_topic == "subdivide") {
        showMethodHelp("subdivide");
    } else if (lower_topic == "hassubdivision") {
        showMethodHelp("hasSubdivision");
    } else if (lower_topic == "getsubcell") {
        showMethodHelp("getSubCell");
    } else if (lower_topic == "updatesubcellvertex") {
        showMethodHelp("updateSubCellVertex");
    } else if (lower_topic == "refreshtriangulation") {
        showMethodHelp("refreshTriangulation");
    } else if (lower_topic == "getplane") {
        showMethodHelp("getPlane");
    } else if (lower_topic == "getplanefacets") {
        showMethodHelp("getPlaneFacets");
    } else if (lower_topic == "getcheckerboardfacets") {
        showMethodHelp("getCheckerboardFacets");
    } else {
        std::cout << "âŒ Unknown topic: '" << topic << "'\n";
        std::cout << "ğŸ’¡ Use help() with no parameters to see available topics.\n\n";
    }
}

private:
    void showGeneralHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           CUBE CLASS HELP SYSTEM                               â”‚
â”‚                         Advanced 3D Cube with Subdivision                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

OVERVIEW:
The Cube class represents a 3D cube that can be subdivided into smaller subcubes.
Each cube consists of 8 vertices and 12 triangular faces. Subdivision creates
nÃ—nÃ—n smaller cubes, each maintaining independent geometry and properties.

HELP CATEGORIES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CATEGORY            â”‚ DESCRIPTION                                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ constructors        â”‚ Object creation and initialization                      â”‚
â”‚ basic               â”‚ Basic cube operations (geometry, access)               â”‚
â”‚ subdivision         â”‚ Creating and managing subdivisions                     â”‚
â”‚ coordinates         â”‚ Coordinate system conversion                            â”‚
â”‚ subcells            â”‚ Individual subcell access and manipulation             â”‚
â”‚ vertices            â”‚ Vertex modification and geometry updates               â”‚
â”‚ planes              â”‚ 2D plane extraction from 3D subdivision               â”‚
â”‚ patterns            â”‚ Pattern-based subcell selection                        â”‚
â”‚ facets              â”‚ Triangular face generation and access                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

USAGE EXAMPLES:
  cube.help("constructors")     // Learn about object creation
  cube.help("subdivision")      // Learn about subdivision operations
  cube.help("getSubCell")       // Get help for specific method
  cube.help("coordinates")      // Learn coordinate systems

QUICK START:
  Cube cube(1.0, Vector3D(0,0,0));        // Create basic cube
  cube.subdivide(3);                       // Create 3Ã—3Ã—3 = 27 subcubes
  if (cube.hasSubdivision()) {             // Always check before subdivision ops
    auto center = cube.getSubCell(0,0,0);  // Access center subcube
  }

)" << std::endl;
    }
    
    void showConstructorHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CONSTRUCTORS HELP                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. DEFAULT CONSTRUCTOR
   Cube()
   
   Creates an empty cube with no geometry.
   
   USAGE:
     Cube cube;                    // Create empty cube
     // Must call initVertices manually or assign from another cube
   
   WHEN TO USE: When you need to create a cube object that will be initialized later.

2. BASIC CUBE CONSTRUCTOR  
   Cube(double radius, const Vector3D& center)
   
   Creates a cube with 8 vertices and 12 triangular faces.
   
   PARAMETERS:
     radius - Half the side length (distance from center to face)
     center - 3D position for the cube center
   
   USAGE:
     Cube cube(1.0, Vector3D(0,0,0));     // Unit cube at origin
     Cube cube(2.5, Vector3D(5,3,1));     // Larger cube at (5,3,1)
   
   RESULT: cube.faceCount() returns 12, hasSubdivision() returns false

3. SUBDIVIDED CUBE CONSTRUCTOR
   Cube(double radius, const Vector3D& center, int subdivisions)
   
   Creates a cube and immediately subdivides it into nÃ—nÃ—n subcubes.
   
   PARAMETERS:
     radius      - Half the side length of the main cube
     center      - 3D position for the cube center  
     subdivisions - Number of divisions per axis (n means nÂ³ total subcubes)
   
   USAGE:
     Cube cube(1.0, Vector3D(0,0,0), 3);  // 3Ã—3Ã—3 = 27 subcubes
     Cube cube(2.0, Vector3D(1,1,1), 5);  // 5Ã—5Ã—5 = 125 subcubes
   
   RESULT: cube.faceCount() returns nÂ³Ã—12, hasSubdivision() returns true

COPY/MOVE CONSTRUCTORS (Rule of Zero):
   Cube(const Cube& other)        // Deep copy
   Cube(Cube&& other) noexcept    // Efficient move
   
   These are automatically generated and handle all internal data correctly.

MEMORY MANAGEMENT:
   All constructors use RAII principles. No manual memory management required.
   std::vector handles all dynamic allocation internally.

)" << std::endl;
    }
    
    void showBasicOperationsHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           BASIC OPERATIONS HELP                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

These methods work on any cube (subdivided or not):

ACCESS & QUERY METHODS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ size_t faceCount() const noexcept                                              â”‚
â”‚   Returns the total number of triangular faces.                                â”‚
â”‚   â€¢ Basic cube: 12 triangular faces                                            â”‚
â”‚   â€¢ Subdivided cube: nÂ³ Ã— 12 triangular faces                                  â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     std::cout << cube.faceCount();        // Outputs: 12                       â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     std::cout << cube.faceCount();        // Outputs: 324 (27Ã—12)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const Facet& operator[](size_t k) const                                        â”‚
â”‚   Access a specific triangular face by index.                                  â”‚
â”‚   â€¢ k must be in range [0, faceCount())                                        â”‚
â”‚   â€¢ Returns reference to triangular face                                       â”‚
â”‚   â€¢ Throws std::out_of_range if k is invalid                                   â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     const Facet& face = cube[0];         // Get first triangle                 â”‚
â”‚     for (size_t i = 0; i < cube.faceCount(); ++i) {                           â”‚
â”‚       std::cout << cube[i] << std::endl; // Print all triangles               â”‚
â”‚     }                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const FacetBox& getFacets() const noexcept                                     â”‚
â”‚   Get direct access to the collection of all triangular faces.                 â”‚
â”‚   â€¢ Returns const reference to internal FacetBox                               â”‚
â”‚   â€¢ Useful for batch operations or rendering systems                           â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     const FacetBox& faces = cube.getFacets();                                 â”‚
â”‚     // Pass to rendering system that expects FacetBox                          â”‚
â”‚     renderer.draw(faces);                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GEOMETRIC OPERATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vector3D center() const                                                         â”‚
â”‚   Calculate geometric center by averaging all vertex positions.                â”‚
â”‚   â€¢ For basic cubes: matches original center parameter                         â”‚
â”‚   â€¢ For subdivided cubes: center of overall structure                          â”‚
â”‚   â€¢ Throws std::runtime_error if no vertices initialized                       â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(5,3,1));                                          â”‚
â”‚     Vector3D c = cube.center();          // c = (5,3,1)                       â”‚
â”‚     cube.translate(Vector3D(2,0,0));                                           â”‚
â”‚     Vector3D new_c = cube.center();      // new_c = (7,3,1)                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void translate(const Vector3D& offset)                                         â”‚
â”‚   Move the entire cube by adding offset to all vertex positions.               â”‚
â”‚   â€¢ Affects main vertices and subdivision data                                 â”‚
â”‚   â€¢ Automatically rebuilds triangulation                                       â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     cube.translate(Vector3D(5,3,1));     // Move to (5,3,1)                   â”‚
â”‚     cube.translate(Vector3D(0,0,10));    // Move up by 10 units               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void scale(double s, const Vector3D& pivot)                                    â”‚
â”‚   Scale all vertices relative to a pivot point.                                â”‚
â”‚   â€¢ s > 1.0: makes cube larger, s < 1.0: makes cube smaller                   â”‚
â”‚   â€¢ pivot: fixed point that doesn't move during scaling                       â”‚
â”‚   â€¢ Automatically rebuilds triangulation                                       â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     Vector3D center = cube.center();                                           â”‚
â”‚     cube.scale(2.0, center);             // Double size around center         â”‚
â”‚     cube.scale(0.5, Vector3D(0,0,0));    // Half size around origin          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showSubdivisionHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            SUBDIVISION HELP                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CREATING SUBDIVISIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void subdivide(int n)                                                           â”‚
â”‚   Divide cube into nÃ—nÃ—n smaller subcubes, each with 12 triangular faces.     â”‚
â”‚   â€¢ Replaces simple cube with complex subdivided structure                     â”‚
â”‚   â€¢ Creates nÂ³ independent subcubes in 3D grid                                 â”‚
â”‚   â€¢ Each subcube has 8 vertices and generates 12 triangular faces             â”‚
â”‚   â€¢ Total triangular faces becomes nÂ³ Ã— 12                                     â”‚
â”‚                                                                                 â”‚
â”‚   PARAMETERS:                                                                   â”‚
â”‚     n - Number of divisions per axis (must be > 0)                             â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLES:                                                                     â”‚
â”‚     cube.subdivide(2);    // 2Ã—2Ã—2 = 8 subcubes, 96 triangular faces         â”‚
â”‚     cube.subdivide(3);    // 3Ã—3Ã—3 = 27 subcubes, 324 triangular faces       â”‚
â”‚     cube.subdivide(10);   // 10Ã—10Ã—10 = 1000 subcubes, 12000 faces           â”‚
â”‚                                                                                 â”‚
â”‚   VISUAL (n=3):                                                                â”‚
â”‚     Original: 1 cube â†’ After subdivide(3): 27 smaller cubes                   â”‚
â”‚     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]  â†’  [â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆ]                                           â”‚
â”‚                       [â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€]                                           â”‚
â”‚                       [â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆ]                                           â”‚
â”‚                       [â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€]                                           â”‚
â”‚                       [â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆâ”‚â–ˆâ–ˆâ–ˆ]                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CHECKING SUBDIVISION STATUS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ bool hasSubdivision() const noexcept                                           â”‚
â”‚   Check if subdivision has been performed and data is available.               â”‚
â”‚   â€¢ Returns true only if subdivide() was called successfully                   â”‚
â”‚   â€¢ ALWAYS check this before using subdivision-specific methods                â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     if (cube.hasSubdivision()) {                                               â”‚
â”‚       // This won't execute - no subdivision yet                               â”‚
â”‚     }                                                                           â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     if (cube.hasSubdivision()) {                                               â”‚
â”‚       // Now this executes - subdivision exists                                â”‚
â”‚       auto cell = cube.getSubCell(0,0,0);                                     â”‚
â”‚     }                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ int getSubdivisionLevels() const noexcept                                      â”‚
â”‚   Get the current subdivision parameter (n from subdivide(n)).                 â”‚
â”‚   â€¢ Returns 0 for non-subdivided cubes                                         â”‚
â”‚   â€¢ Returns n for cubes with nÃ—nÃ—n subdivision                                 â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube cube(1.0, Vector3D(0,0,0));                                          â”‚
â”‚     std::cout << cube.getSubdivisionLevels();  // Outputs: 0                  â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     std::cout << cube.getSubdivisionLevels();  // Outputs: 5                  â”‚
â”‚     int total_subcubes = std::pow(cube.getSubdivisionLevels(), 3);            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SUBDIVISION WORKFLOW:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. Create cube:     Cube cube(radius, center);                                 â”‚
â”‚ 2. Check status:    if (!cube.hasSubdivision()) { ... }                       â”‚
â”‚ 3. Subdivide:       cube.subdivide(n);                                        â”‚
â”‚ 4. Verify:          assert(cube.hasSubdivision());                            â”‚
â”‚ 5. Use methods:     cube.getSubCell(x,y,z), cube.getPlane(), etc.            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PERFORMANCE CONSIDERATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Subdivision creates nÂ³ subcubes - memory usage grows cubically               â”‚
â”‚ â€¢ n=10: 1,000 subcubes, n=20: 8,000 subcubes, n=50: 125,000 subcubes        â”‚
â”‚ â€¢ Each subcube stores 8 vertices + metadata                                    â”‚
â”‚ â€¢ Consider using subdivision selectively for detailed areas only               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showCoordinateHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           COORDINATE SYSTEMS HELP                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

The Cube class uses two coordinate systems for subdivision access:

LOGICAL COORDINATES (User-Friendly):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Origin (0,0,0) at the CENTER of the subdivision                              â”‚
â”‚ â€¢ Negative coordinates extend toward -X, -Y, -Z                                â”‚
â”‚ â€¢ Positive coordinates extend toward +X, +Y, +Z                                â”‚
â”‚ â€¢ Range depends on subdivision level n                                         â”‚
â”‚ â€¢ Used in all public API methods                                               â”‚
â”‚                                                                                 â”‚
â”‚ COORDINATE RANGES (for subdivision level n):                                   â”‚
â”‚   n=3: range [-1, 1]     n=4: range [-2, 1]     n=5: range [-2, 2]           â”‚
â”‚   n=6: range [-3, 2]     n=7: range [-3, 3]     n=8: range [-4, 3]           â”‚
â”‚                                                                                 â”‚
â”‚ VISUAL EXAMPLE (n=5, Z=0 plane):                                               â”‚
â”‚   (-2,2,0) â”‚(-1,2,0) â”‚(0,2,0) â”‚(1,2,0) â”‚(2,2,0)                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚   (-2,1,0) â”‚(-1,1,0) â”‚(0,1,0) â”‚(1,1,0) â”‚(2,1,0)                             â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚   (-2,0,0) â”‚(-1,0,0) â”‚(0,0,0) â”‚(1,0,0) â”‚(2,0,0)  â† CENTER                   â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚   (-2,-1,0)â”‚(-1,-1,0)â”‚(0,-1,0)â”‚(1,-1,0)â”‚(2,-1,0)                            â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€                             â”‚
â”‚   (-2,-2,0)â”‚(-1,-2,0)â”‚(0,-2,0)â”‚(1,-2,0)â”‚(2,-2,0)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PHYSICAL COORDINATES (Internal Array Indices):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Origin (0,0,0) at FIRST array element                                        â”‚
â”‚ â€¢ Always non-negative integers                                                 â”‚
â”‚ â€¢ Range [0, n) for subdivision level n                                         â”‚
â”‚ â€¢ Used for internal array indexing: subcells_[i][j][k]                        â”‚
â”‚ â€¢ Rarely used in public API                                                    â”‚
â”‚                                                                                 â”‚
â”‚ VISUAL EXAMPLE (n=5, Z=2 plane):                                               â”‚
â”‚   (0,4,2) â”‚(1,4,2) â”‚(2,4,2) â”‚(3,4,2) â”‚(4,4,2)                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚   (0,3,2) â”‚(1,3,2) â”‚(2,3,2) â”‚(3,3,2) â”‚(4,3,2)                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚   (0,2,2) â”‚(1,2,2) â”‚(2,2,2) â”‚(3,2,2) â”‚(4,2,2)  â† CENTER                     â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚   (0,1,2) â”‚(1,1,2) â”‚(2,1,2) â”‚(3,1,2) â”‚(4,1,2)                               â”‚
â”‚   â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚   (0,0,2) â”‚(1,0,2) â”‚(2,0,2) â”‚(3,0,2) â”‚(4,0,2)                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CONVERSION METHODS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ std::tuple<int,int,int> logicalToPhysical(int x, int y, int z) const           â”‚
â”‚   Convert user-friendly logical coordinates to internal array indices.         â”‚
â”‚   â€¢ Required before subdivision operations                                     â”‚
â”‚   â€¢ Throws std::runtime_error if no subdivision available                      â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     auto [i,j,k] = cube.logicalToPhysical(0, 0, 0);  // Returns (2,2,2)      â”‚
â”‚     auto [i,j,k] = cube.logicalToPhysical(2, 1, -1); // Returns (4,3,1)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ std::tuple<int,int,int> physicalToLogical(int i, int j, int k) const           â”‚
â”‚   Convert internal array indices back to user-friendly logical coordinates.    â”‚
â”‚   â€¢ Useful for converting processing results back to user space               â”‚
â”‚   â€¢ Throws std::runtime_error if no subdivision available                      â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     auto [x,y,z] = cube.physicalToLogical(2, 2, 2);  // Returns (0,0,0)      â”‚
â”‚     auto [x,y,z] = cube.physicalToLogical(4, 3, 1);  // Returns (2,1,-1)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COORDINATE MAPPING TABLE (n=5):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LOGICAL      â”‚ PHYSICAL     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ (-2,-2,-2)   â”‚ (0,0,0)      â”‚
â”‚ (-1,-1,-1)   â”‚ (1,1,1)      â”‚
â”‚ (0,0,0)      â”‚ (2,2,2)      â”‚ â† CENTER
â”‚ (1,1,1)      â”‚ (3,3,3)      â”‚
â”‚ (2,2,2)      â”‚ (4,4,4)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

USAGE GUIDELINES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ ALWAYS use logical coordinates in public API calls                           â”‚
â”‚ â€¢ Use getSubCell(0,0,0) to access center subcube                              â”‚
â”‚ â€¢ Use positive/negative values to access subcubes relative to center           â”‚
â”‚ â€¢ Physical coordinates are mainly for internal implementation                  â”‚
â”‚ â€¢ Conversion methods help when you need to work with both systems             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showSubcellHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              SUBCELL ACCESS HELP                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHAT IS A SUBCELL:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ A SubCell is a smaller cube within the subdivision with:                       â”‚
â”‚ â€¢ 8 vertices (Vector3D positions)                                              â”‚
â”‚ â€¢ Center position and radius                                                   â”‚
â”‚ â€¢ Grid coordinates (i,j,k)                                                     â”‚
â”‚ â€¢ Active/inactive state for selective rendering                                â”‚
â”‚ â€¢ Capability to generate 12 triangular faces                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

READ-ONLY SUBCELL ACCESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const SubCell& getSubCell(int x, int y, int z) const                           â”‚
â”‚   Access subcell using logical coordinates (user-friendly).                    â”‚
â”‚   â€¢ (0,0,0) = center subcell                                                   â”‚
â”‚   â€¢ Positive/negative values extend from center                                â”‚
â”‚   â€¢ Automatic coordinate validation and conversion                             â”‚
â”‚   â€¢ Throws std::out_of_range if coordinates invalid                            â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     const SubCell& center = cube.getSubCell(0, 0, 0);    // Center subcell    â”‚
â”‚     const SubCell& corner = cube.getSubCell(2, 2, 2);    // Corner subcell    â”‚
â”‚     const SubCell& edge = cube.getSubCell(-1, 0, 1);     // Edge subcell      â”‚
â”‚                                                                                 â”‚
â”‚     // Access subcell properties                                               â”‚
â”‚     Vector3D center_pos = center.center;                                       â”‚
â”‚     double radius = center.radius;                                             â”‚
â”‚     bool is_active = center.active;                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const SubCell& getSubCellPhysical(int i, int j, int k) const                   â”‚
â”‚   Access subcell using physical array indices (for internal use).              â”‚
â”‚   â€¢ i,j,k must be in range [0, n) where n = subdivision levels                â”‚
â”‚   â€¢ Direct array access without coordinate conversion                          â”‚
â”‚   â€¢ Mainly used for performance-critical internal operations                   â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     const SubCell& center = cube.getSubCellPhysical(2, 2, 2);  // Center      â”‚
â”‚     const SubCell& origin = cube.getSubCellPhysical(0, 0, 0);  // Array start â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

MODIFIABLE SUBCELL ACCESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SubCell& getSubCellMutable(int x, int y, int z)                                â”‚
â”‚   Get modifiable access to subcell for property changes.                       â”‚
â”‚   â€¢ Use for changing vertices, center, radius, or active state                â”‚
â”‚   â€¢ May require refreshTriangulation() after vertex changes                   â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     SubCell& cell = cube.getSubCellMutable(0, 0, 0);                          â”‚
â”‚     cell.active = false;                  // Disable for rendering             â”‚
â”‚     cell.vertices[0] = Vector3D(1,2,3);   // Modify vertex position           â”‚
â”‚     cube.refreshTriangulation();          // Update triangular faces           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SUBCELL PROPERTY ACCESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Vector3D getSubcellCenter(int x, int y, int z) const                           â”‚
â”‚   Get the 3D center position of a specific subcell.                           â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Vector3D center_pos = cube.getSubcellCenter(0, 0, 0);                     â”‚
â”‚     Vector3D corner_pos = cube.getSubcellCenter(1, 1, 1);                     â”‚
â”‚     double distance = (corner_pos - center_pos).magnitude();                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ double getSubcellRadius(int x, int y, int z) const                             â”‚
â”‚   Get corner-to-center distance (3D diagonal) of a specific subcell.          â”‚
â”‚   â€¢ Returns sqrt(3) * half_side_length                                         â”‚
â”‚   â€¢ Useful for collision detection and bounding sphere calculations            â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     double radius = cube.getSubcellRadius(0, 0, 0);                           â”‚
â”‚     // Use radius for collision detection or spatial queries                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void setSubCellActive(int x, int y, int z, bool active)                        â”‚
â”‚   Enable/disable a subcell for rendering and processing.                       â”‚
â”‚   â€¢ Inactive subcells are skipped during facet generation                     â”‚
â”‚   â€¢ Useful for selective visualization and performance optimization            â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.setSubCellActive(0, 0, 0, false);   // Disable center subcell        â”‚
â”‚     cube.setSubCellActive(1, 1, 1, true);    // Enable corner subcell         â”‚
â”‚                                                                                 â”‚
â”‚     // Inactive subcells won't appear in facet generation                     â”‚
â”‚     FacetBox faces = cube.getSubCellFacets(0, 0, 0);  // Returns empty        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

SUBCELL STRUCTURE DETAILS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ struct SubCell {                                                                â”‚
â”‚   std::array<Vector3D, 8> vertices;  // 8 corner positions                    â”‚
â”‚   Vector3D center;                    // Geometric center                      â”‚
â”‚   double radius;                      // Half side length                      â”‚
â”‚   int i, j, k;                       // Physical grid position                 â”‚
â”‚   bool active;                       // Rendering enable flag                  â”‚
â”‚ }                                                                               â”‚
â”‚                                                                                 â”‚
â”‚ VERTEX ORDERING (same as main cube):                                           â”‚
â”‚   0: front-bottom-left    4: back-bottom-left                                  â”‚
â”‚   1: front-bottom-right   5: back-bottom-right                                 â”‚
â”‚   2: front-top-right      6: back-top-right                                    â”‚
â”‚   3: front-top-left       7: back-top-left                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMMON USAGE PATTERNS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ // Iterate through all subcells                                                â”‚
â”‚ int n = cube.getSubdivisionLevels();                                           â”‚
â”‚ for (int x = -n/2; x <= n/2; ++x) {                                           â”‚
â”‚   for (int y = -n/2; y <= n/2; ++y) {                                         â”‚
â”‚     for (int z = -n/2; z <= n/2; ++z) {                                       â”‚
â”‚       if (/* valid coordinates */) {                                          â”‚
â”‚         const SubCell& cell = cube.getSubCell(x, y, z);                       â”‚
â”‚         // Process subcell...                                                  â”‚
â”‚       }                                                                        â”‚
â”‚     }                                                                          â”‚
â”‚   }                                                                            â”‚
â”‚ }                                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showVertexHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                            VERTEX MANIPULATION HELP                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VERTEX MODIFICATION:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void updateSubCellVertex(int x, int y, int z, int vertex_idx,                  â”‚
â”‚                          const Vector3D& new_pos)                             â”‚
â”‚   Modify the position of a specific vertex within a subcell.                   â”‚
â”‚   â€¢ Enables geometric deformation and custom shape creation                    â”‚
â”‚   â€¢ Changes are local to the specified subcell                                â”‚
â”‚   â€¢ Requires refreshTriangulation() call afterward                            â”‚
â”‚                                                                                 â”‚
â”‚   PARAMETERS:                                                                   â”‚
â”‚     x,y,z      - Logical coordinates of target subcell                         â”‚
â”‚     vertex_idx - Vertex index [0,7] within the subcell                        â”‚
â”‚     new_pos    - New 3D position for the vertex                               â”‚
â”‚                                                                                 â”‚
â”‚   VERTEX INDEX REFERENCE:                                                       â”‚
â”‚     0: front-bottom-left     4: back-bottom-left                               â”‚
â”‚     1: front-bottom-right    5: back-bottom-right                              â”‚
â”‚     2: front-top-right       6: back-top-right                                 â”‚
â”‚     3: front-top-left        7: back-top-left                                  â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     // Move vertex 0 of center subcell                                        â”‚
â”‚     cube.updateSubCellVertex(0, 0, 0, 0, Vector3D(1.5, 1.5, 1.5));          â”‚
â”‚     // Move vertex 7 of another subcell                                       â”‚
â”‚     cube.updateSubCellVertex(1, 0, 0, 7, Vector3D(2.0, 2.0, 2.0));          â”‚
â”‚     cube.refreshTriangulation();  // REQUIRED after vertex changes            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

TRIANGULATION REFRESH:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ void refreshTriangulation()                                                     â”‚
â”‚   Rebuild all triangular faces after vertex modifications.                     â”‚
â”‚   â€¢ Scans all subcells and regenerates their triangular faces                 â”‚
â”‚   â€¢ Skips inactive subcells automatically                                     â”‚
â”‚   â€¢ Expensive operation - batch vertex updates before calling                 â”‚
â”‚   â€¢ MUST be called after any updateSubCellVertex() operations                 â”‚
â”‚                                                                                 â”‚
â”‚   USAGE PATTERN:                                                               â”‚
â”‚     // Batch multiple vertex updates                                           â”‚
â”‚     cube.updateSubCellVertex(0, 0, 0, 0, pos1);                              â”‚
â”‚     cube.updateSubCellVertex(0, 0, 0, 1, pos2);                              â”‚
â”‚     cube.updateSubCellVertex(1, 1, 1, 3, pos3);                              â”‚
â”‚     // Single refresh call for all changes                                    â”‚
â”‚     cube.refreshTriangulation();                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

VERTEX MANIPULATION EXAMPLES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. SIMPLE DEFORMATION:                                                         â”‚
â”‚    cube.subdivide(5);                                                          â”‚
â”‚    // Pull center vertex upward                                               â”‚
â”‚    Vector3D center_pos = cube.getSubcellCenter(0, 0, 0);                      â”‚
â”‚    cube.updateSubCellVertex(0, 0, 0, 2, center_pos + Vector3D(0, 2, 0));     â”‚
â”‚    cube.refreshTriangulation();                                                â”‚
â”‚                                                                                 â”‚
â”‚ 2. CREATE WAVE PATTERN:                                                        â”‚
â”‚    cube.subdivide(10);                                                         â”‚
â”‚    int n = cube.getSubdivisionLevels();                                        â”‚
â”‚    for (int x = -n/2; x < n/2; ++x) {                                         â”‚
â”‚      for (int z = -n/2; z < n/2; ++z) {                                       â”‚
â”‚        double height = sin(x * 0.5) * cos(z * 0.5);                          â”‚
â”‚        Vector3D offset(0, height, 0);                                          â”‚
â”‚        // Modify top vertices (indices 2,3,6,7)                               â”‚
â”‚        Vector3D base_pos = cube.getSubcellCenter(x, 0, z);                     â”‚
â”‚        cube.updateSubCellVertex(x, 0, z, 2, base_pos + offset);               â”‚
â”‚        cube.updateSubCellVertex(x, 0, z, 3, base_pos + offset);               â”‚
â”‚      }                                                                         â”‚
â”‚    }                                                                           â”‚
â”‚    cube.refreshTriangulation();                                                â”‚
â”‚                                                                                 â”‚
â”‚ 3. SELECTIVE MODIFICATION:                                                     â”‚
â”‚    cube.subdivide(3);                                                          â”‚
â”‚    // Only modify corner subcells                                             â”‚
â”‚    std::vector<std::tuple<int,int,int>> corners = {                           â”‚
â”‚      {-1,-1,-1}, {1,-1,-1}, {-1,1,-1}, {1,1,-1},                            â”‚
â”‚      {-1,-1,1},  {1,-1,1},  {-1,1,1},  {1,1,1}                              â”‚
â”‚    };                                                                          â”‚
â”‚    for (auto [x,y,z] : corners) {                                             â”‚
â”‚      Vector3D center = cube.getSubcellCenter(x, y, z);                        â”‚
â”‚      Vector3D expanded = center * 1.5;  // Expand from origin                 â”‚
â”‚      cube.updateSubCellVertex(x, y, z, 0, expanded);                          â”‚
â”‚    }                                                                           â”‚
â”‚    cube.refreshTriangulation();                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PERFORMANCE CONSIDERATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ refreshTriangulation() complexity: O(nÂ³) where n = subdivision levels       â”‚
â”‚ â€¢ For n=10: processes 1,000 subcells Ã— 12 triangles = 12,000 triangles       â”‚
â”‚ â€¢ Batch vertex updates to minimize triangulation rebuilds                     â”‚
â”‚ â€¢ Consider using setSubCellActive(false) to skip expensive subcells           â”‚
â”‚ â€¢ Vertex modifications are persistent until overwritten                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

GEOMETRIC EFFECTS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â€¢ Moving vertices creates non-cubic shapes                                     â”‚
â”‚ â€¢ Triangular faces automatically adapt to new vertex positions                â”‚
â”‚ â€¢ Shared vertices between subcells are independent (no automatic connection)  â”‚
â”‚ â€¢ Large vertex movements may cause face intersection or inversion             â”‚
â”‚ â€¢ Consider gradual modifications for smooth deformations                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showPlaneHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              PLANE EXTRACTION HELP                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHAT ARE PLANES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Planes are 2D slices through the 3D subdivision grid:                         â”‚
â”‚ â€¢ XY plane: varies X and Y, fixes Z (perpendicular to Z-axis)                 â”‚
â”‚ â€¢ XZ plane: varies X and Z, fixes Y (perpendicular to Y-axis)                 â”‚
â”‚ â€¢ YZ plane: varies Y and Z, fixes X (perpendicular to X-axis)                 â”‚
â”‚ â€¢ Each plane contains nÃ—n subcells for subdivision level n                    â”‚
â”‚ â€¢ Useful for layer-by-layer analysis and rendering                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

NUMERIC PLANE ACCESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ std::vector<std::reference_wrapper<const SubCell>>                             â”‚
â”‚ getPlane(int axis, int layer) const                                            â”‚
â”‚   Extract all subcells from a specific 2D plane.                              â”‚
â”‚   â€¢ Returns references to subcells (not copies)                               â”‚
â”‚   â€¢ Subcells maintain their original properties and state                     â”‚
â”‚                                                                                 â”‚
â”‚   PARAMETERS:                                                                   â”‚
â”‚     axis  - Plane orientation: 0=YZ, 1=XZ, 2=XY                               â”‚
â”‚     layer - Physical layer index [0, n) within the axis                       â”‚
â”‚                                                                                 â”‚
â”‚   AXIS MAPPING:                                                                â”‚
â”‚     0 (YZ plane): fixes X coordinate, varies Y and Z                          â”‚
â”‚     1 (XZ plane): fixes Y coordinate, varies X and Z                          â”‚
â”‚     2 (XY plane): fixes Z coordinate, varies X and Y                          â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(5);                                                         â”‚
â”‚     // Get center XY plane (Z=2 in physical coordinates)                      â”‚
â”‚     auto xy_plane = cube.getPlane(2, 2);                                      â”‚
â”‚     std::cout << "XY plane has " << xy_plane.size() << " subcells\n";         â”‚
â”‚     // For n=5: outputs "XY plane has 25 subcells"                           â”‚
â”‚                                                                                 â”‚
â”‚     // Process each subcell in the plane                                      â”‚
â”‚     for (const SubCell& cell : xy_plane) {                                    â”‚
â”‚       std::cout << "Center: " << cell.center << std::endl;                    â”‚
â”‚     }                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getPlaneFacets(int axis, int layer) const                             â”‚
â”‚   Generate triangular faces for all subcells in a plane.                      â”‚
â”‚   â€¢ Returns complete triangulation for the plane                              â”‚
â”‚   â€¢ Skips inactive subcells automatically                                     â”‚
â”‚   â€¢ Each active subcell contributes 12 triangular faces                       â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     FacetBox xy_faces = cube.getPlaneFacets(2, 1);  // XY plane, layer 1     â”‚
â”‚     std::cout << xy_faces.size() << " triangular faces\n";                    â”‚
â”‚     // For 3Ã—3 plane with all active: outputs "108 triangular faces"         â”‚
â”‚                                                                                 â”‚
â”‚     // Use for rendering specific layers                                       â”‚
â”‚     renderer.drawFacets(xy_faces);                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

STRING-BASED PLANE ACCESS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getPlaneFacets(const std::string& coord1,                             â”‚
â”‚                        const std::string& coord2,                             â”‚
â”‚                        const std::string& coord3) const                       â”‚
â”‚   User-friendly plane specification using string coordinates.                  â”‚
â”‚   â€¢ Two coordinates must be axis names: "x", "y", "z"                         â”‚
â”‚   â€¢ One coordinate must be numeric: "0", "-1", "2", etc.                      â”‚
â”‚   â€¢ Numeric value uses logical coordinate system                               â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLES:                                                                     â”‚
â”‚     // Center XY plane (Z=0 in logical coordinates)                           â”‚
â”‚     FacetBox xy_center = cube.getPlaneFacets("x", "y", "0");                  â”‚
â”‚                                                                                 â”‚
â”‚     // XZ plane above center (Y=1 in logical coordinates)                     â”‚
â”‚     FacetBox xz_up = cube.getPlaneFacets("x", "1", "z");                      â”‚
â”‚                                                                                 â”‚
â”‚     // YZ plane to the right (X=2 in logical coordinates)                     â”‚
â”‚     FacetBox yz_right = cube.getPlaneFacets("2", "y", "z");                   â”‚
â”‚                                                                                 â”‚
â”‚   COORDINATE VALIDATION:                                                        â”‚
â”‚     âœ“ Valid: ("x", "y", "0"), ("1", "y", "z"), ("x", "-1", "z")              â”‚
â”‚     âœ— Invalid: ("x", "y", "z"), ("1", "2", "z"), ("", "y", "0")              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PLANE COORDINATE MAPPING:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ For subdivision level n=5:                                                     â”‚
â”‚                                                                                 â”‚
â”‚ LOGICAL TO PHYSICAL LAYER CONVERSION:                                           â”‚
â”‚   Logical -2 â†’ Physical 0    Logical 0 â†’ Physical 2 (center)                  â”‚
â”‚   Logical -1 â†’ Physical 1    Logical 1 â†’ Physical 3                           â”‚
â”‚   Logical  2 â†’ Physical 4                                                      â”‚
â”‚                                                                                 â”‚
â”‚ STRING COORDINATE EXAMPLES:                                                     â”‚
â”‚   "x","y","0"  â†’ XY plane at logical Z=0 â†’ Physical layer 2                   â”‚
â”‚   "x","y","-1" â†’ XY plane at logical Z=-1 â†’ Physical layer 1                  â”‚
â”‚   "0","y","z"  â†’ YZ plane at logical X=0 â†’ Physical layer 2                   â”‚
â”‚   "1","y","z"  â†’ YZ plane at logical X=1 â†’ Physical layer 3                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PLANE VISUALIZATION (n=3):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ XY PLANES (axis=2, varying Z):          YZ PLANES (axis=0, varying X):        â”‚
â”‚   Layer 0: Z=-1  Layer 1: Z=0  Layer 2: Z=1                                   â”‚
â”‚   â”Œâ”€â”¬â”€â”¬â”€â”       â”Œâ”€â”¬â”€â”¬â”€â”       â”Œâ”€â”¬â”€â”¬â”€â”    â”Œâ”€â”¬â”€â”¬â”€â” â”Œâ”€â”¬â”€â”¬â”€â” â”Œâ”€â”¬â”€â”¬â”€â”           â”‚
â”‚   â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚    â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚           â”‚
â”‚   â”œâ”€â”¼â”€â”¼â”€â”¤       â”œâ”€â”¼â”€â”¼â”€â”¤       â”œâ”€â”¼â”€â”¼â”€â”¤    â”œâ”€â”¼â”€â”¼â”€â”¤ â”œâ”€â”¼â”€â”¼â”€â”¤ â”œâ”€â”¼â”€â”¼â”€â”¤           â”‚
â”‚   â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚    â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚           â”‚
â”‚   â”œâ”€â”¼â”€â”¼â”€â”¤       â”œâ”€â”¼â”€â”¼â”€â”¤       â”œâ”€â”¼â”€â”¼â”€â”¤    â”œâ”€â”¼â”€â”¼â”€â”¤ â”œâ”€â”¼â”€â”¼â”€â”¤ â”œâ”€â”¼â”€â”¼â”€â”¤           â”‚
â”‚   â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚       â”‚ â”‚ â”‚ â”‚    â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ â”‚           â”‚
â”‚   â””â”€â”´â”€â”´â”€â”˜       â””â”€â”´â”€â”´â”€â”˜       â””â”€â”´â”€â”´â”€â”˜    â””â”€â”´â”€â”´â”€â”˜ â””â”€â”´â”€â”´â”€â”˜ â””â”€â”´â”€â”´â”€â”˜           â”‚
â”‚             Back to Front               X=-1    X=0    X=1                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMMON USAGE PATTERNS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. LAYER-BY-LAYER PROCESSING:                                                 â”‚
â”‚    cube.subdivide(5);                                                          â”‚
â”‚    int n = cube.getSubdivisionLevels();                                        â”‚
â”‚    for (int layer = 0; layer < n; ++layer) {                                  â”‚
â”‚      auto xy_plane = cube.getPlane(2, layer);  // Get XY plane at layer      â”‚
â”‚      std::cout << "Layer " << layer << " has "                                â”‚
â”‚                 << xy_plane.size() << " subcells\n";                          â”‚
â”‚    }                                                                           â”‚
â”‚                                                                                â”‚
â”‚ 2. CENTER PLANE ANALYSIS:                                                     â”‚
â”‚    FacetBox center_xy = cube.getPlaneFacets("x", "y", "0");                   â”‚
â”‚    FacetBox center_xz = cube.getPlaneFacets("x", "0", "z");                   â”‚
â”‚    FacetBox center_yz = cube.getPlaneFacets("0", "y", "z");                   â”‚
â”‚                                                                                â”‚
â”‚ 3. SELECTIVE LAYER RENDERING:                                                 â”‚
â”‚    for (int z = -2; z <= 2; ++z) {                                            â”‚
â”‚      FacetBox layer = cube.getPlaneFacets("x", "y", std::to_string(z));       â”‚
â”‚      renderer.drawLayer(layer, z);                                             â”‚
â”‚    }                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showPatternHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                           PATTERN SELECTION HELP                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

CHECKERBOARD PATTERN:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ std::vector<std::reference_wrapper<const SubCell>>                             â”‚
â”‚ getCheckerboardSubcells() const                                                â”‚
â”‚   Extract subcells following a 3D checkerboard pattern.                       â”‚
â”‚   â€¢ Selects subcells where (i+j+k) % 4 == 0 using physical coordinates       â”‚
â”‚   â€¢ Creates spatially distributed selection similar to 2D checkerboard        â”‚
â”‚   â€¢ Reduces density while maintaining even distribution                        â”‚
â”‚   â€¢ Useful for sampling, performance testing, and visual effects              â”‚
â”‚                                                                                 â”‚
â”‚   PATTERN RULE:                                                                â”‚
â”‚     Physical coordinates (i,j,k) where: (i + j + k) divisible by 4           â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(4);                                                         â”‚
â”‚     auto checker_cells = cube.getCheckerboardSubcells();                      â”‚
â”‚     std::cout << checker_cells.size() << " subcells selected\n";              â”‚
â”‚     // For 4Ã—4Ã—4 cube: selects 16 out of 64 subcells                         â”‚
â”‚                                                                                 â”‚
â”‚     for (const SubCell& cell : checker_cells) {                               â”‚
â”‚       std::cout << "Selected: (" << cell.i << "," << cell.j                   â”‚
â”‚                 << "," << cell.k << ")\n";                                    â”‚
â”‚     }                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getCheckerboardFacets() const                                         â”‚
â”‚   Generate triangular faces for all checkerboard pattern subcells.            â”‚
â”‚   â€¢ Returns complete triangulation for selected subcells only                 â”‚
â”‚   â€¢ Automatically skips inactive subcells                                     â”‚
â”‚   â€¢ Each selected active subcell contributes 12 triangular faces              â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(6);                                                         â”‚
â”‚     FacetBox checker_faces = cube.getCheckerboardFacets();                    â”‚
â”‚     std::cout << checker_faces.size() << " triangular faces\n";               â”‚
â”‚                                                                                 â”‚
â”‚     // Use for selective rendering                                             â”‚
â”‚     renderer.setColor(RED);                                                    â”‚
â”‚     renderer.drawFacets(checker_faces);                                        â”‚
â”‚                                                                                 â”‚
â”‚     // Compare with full cube                                                  â”‚
â”‚     FacetBox all_faces = cube.getFacets();                                    â”‚
â”‚     std::cout << "Checkerboard: " << checker_faces.size()                     â”‚
â”‚               << " / Full: " << all_faces.size() << std::endl;                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PATTERN VISUALIZATION:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3D CHECKERBOARD PATTERN (4Ã—4Ã—4 subdivision, showing XY plane at Z=0):        â”‚
â”‚                                                                                 â”‚
â”‚   Physical Coordinates (i,j,k):                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”  Legend:                                          â”‚
â”‚   â”‚(0,3)â”‚(1,3)â”‚(2,3)â”‚(3,3)â”‚  â–  = Selected (sum divisible by 4)               â”‚
â”‚   â”‚  â–¡  â”‚  â–   â”‚  â–¡  â”‚  â–   â”‚  â–¡ = Not selected                                 â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤                                                    â”‚
â”‚   â”‚(0,2)â”‚(1,2)â”‚(2,2)â”‚(3,2)â”‚  Selected coordinates at Z=0:                    â”‚
â”‚   â”‚  â–   â”‚  â–¡  â”‚  â–   â”‚  â–¡  â”‚  (0,0,0): 0+0+0=0 Ã· 4 = 0 âœ“                    â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤  (1,1,0): 1+1+0=2 Ã· 4 = 0.5 âœ—                  â”‚
â”‚   â”‚(0,1)â”‚(1,1)â”‚(2,1)â”‚(3,1)â”‚  (2,0,0): 2+0+0=2 Ã· 4 = 0.5 âœ—                  â”‚
â”‚   â”‚  â–¡  â”‚  â–   â”‚  â–¡  â”‚  â–   â”‚  (2,2,0): 2+2+0=4 Ã· 4 = 1 âœ“                    â”‚
â”‚   â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤                                                    â”‚
â”‚   â”‚(0,0)â”‚(1,0)â”‚(2,0)â”‚(3,0)â”‚                                                   â”‚
â”‚   â”‚  â–   â”‚  â–¡  â”‚  â–   â”‚  â–¡  â”‚                                                   â”‚
â”‚   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PATTERN MATHEMATICS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Selection Rule: (i + j + k) % 4 == 0                                          â”‚
â”‚                                                                                 â”‚
â”‚ For subdivision level n, approximate selection ratio:                          â”‚
â”‚   â€¢ n=2: ~25% of subcells (2/8 = 25%)                                         â”‚
â”‚   â€¢ n=4: ~25% of subcells (16/64 = 25%)                                       â”‚
â”‚   â€¢ n=8: ~25% of subcells (128/512 = 25%)                                     â”‚
â”‚                                                                                 â”‚
â”‚ The pattern maintains roughly 1/4 density while ensuring even distribution     â”‚
â”‚ across all three spatial dimensions.                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

USE CASES FOR CHECKERBOARD PATTERN:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. PERFORMANCE TESTING:                                                        â”‚
â”‚    // Render subset for performance comparison                                 â”‚
â”‚    auto start = std::chrono::high_resolution_clock::now();                     â”‚
â”‚    FacetBox checker = cube.getCheckerboardFacets();                           â”‚
â”‚    renderer.draw(checker);                                                     â”‚
â”‚    auto end = std::chrono::high_resolution_clock::now();                       â”‚
â”‚                                                                                 â”‚
â”‚ 2. LEVEL-OF-DETAIL RENDERING:                                                 â”‚
â”‚    if (distance_to_camera > threshold) {                                      â”‚
â”‚      // Use checkerboard for distant objects                                  â”‚
â”‚      renderer.draw(cube.getCheckerboardFacets());                             â”‚
â”‚    } else {                                                                    â”‚
â”‚      // Use full detail for close objects                                     â”‚
â”‚      renderer.draw(cube.getFacets());                                         â”‚
â”‚    }                                                                           â”‚
â”‚                                                                                 â”‚
â”‚ 3. VISUAL EFFECTS:                                                            â”‚
â”‚    // Animate alternating pattern                                             â”‚
â”‚    renderer.setColor(RED);                                                    â”‚
â”‚    renderer.draw(cube.getCheckerboardFacets());                               â”‚
â”‚    renderer.setColor(BLUE);                                                   â”‚
â”‚    // Draw remaining subcells with different rendering                        â”‚
â”‚                                                                                â”‚
â”‚ 4. SAMPLING AND ANALYSIS:                                                     â”‚
â”‚    auto samples = cube.getCheckerboardSubcells();                             â”‚
â”‚    double total_volume = 0;                                                    â”‚
â”‚    for (const SubCell& cell : samples) {                                      â”‚
â”‚      total_volume += std::pow(cell.radius * 2, 3);  // Volume of each subcell â”‚
â”‚    }                                                                           â”‚
â”‚    double estimated_total = total_volume * 4;  // Scale up sample             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMBINING WITH OTHER OPERATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ // Disable checkerboard subcells for complementary pattern                    â”‚
â”‚ auto checker_cells = cube.getCheckerboardSubcells();                          â”‚
â”‚ for (const SubCell& cell : checker_cells) {                                   â”‚
â”‚   cube.setSubCellActive(/* convert to logical coords */, false);              â”‚
â”‚ }                                                                              â”‚
â”‚ cube.refreshTriangulation();                                                   â”‚
â”‚                                                                                â”‚
â”‚ // Now getFacets() returns the inverse checkerboard pattern                   â”‚
â”‚ FacetBox inverse_pattern = cube.getFacets();                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showFacetHelp() const {
        std::cout << R"(
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                             FACET GENERATION HELP                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

WHAT ARE FACETS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Facets are triangular faces that represent the visual geometry of the cube:    â”‚
â”‚ â€¢ Each cube face is divided into 2 triangular faces                           â”‚
â”‚ â€¢ Basic cube: 6 faces Ã— 2 triangles = 12 triangular faces                     â”‚
â”‚ â€¢ Subdivided cube: nÂ³ subcubes Ã— 12 triangular faces each                     â”‚
â”‚ â€¢ Triangular faces are stored in FacetBox containers                          â”‚
â”‚ â€¢ Each triangular face consists of 3 vertices in 3D space                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

INDIVIDUAL SUBCELL FACETS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getSubCellFacets(int x, int y, int z) const                           â”‚
â”‚   Generate the 12 triangular faces for a single subcell.                      â”‚
â”‚   â€¢ Returns empty FacetBox if subcell is inactive                             â”‚
â”‚   â€¢ Uses current vertex positions (reflects any modifications)                â”‚
â”‚   â€¢ Each subcell always generates exactly 12 triangular faces when active    â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(3);                                                         â”‚
â”‚     FacetBox center_faces = cube.getSubCellFacets(0, 0, 0);                   â”‚
â”‚     std::cout << center_faces.size() << " triangular faces\n";  // Outputs: 12â”‚
â”‚                                                                                 â”‚
â”‚     // Check if subcell is active                                             â”‚
â”‚     if (center_faces.size() == 0) {                                           â”‚
â”‚       std::cout << "Center subcell is inactive\n";                            â”‚
â”‚     }                                                                          â”‚
â”‚                                                                                â”‚
â”‚     // Render individual subcell                                              â”‚
â”‚     renderer.setColor(GREEN);                                                 â”‚
â”‚     renderer.drawFacets(center_faces);                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMPLETE CUBE FACETS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ const FacetBox& getFacets() const noexcept                                     â”‚
â”‚   Get all triangular faces for the entire cube structure.                     â”‚
â”‚   â€¢ For basic cubes: returns 12 triangular faces                              â”‚
â”‚   â€¢ For subdivided cubes: returns nÂ³ Ã— 12 triangular faces (active subcells) â”‚
â”‚   â€¢ Reflects current state (active/inactive subcells, vertex modifications)   â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     Cube basic_cube(1.0, Vector3D(0,0,0));                                    â”‚
â”‚     std::cout << basic_cube.getFacets().size();  // Outputs: 12               â”‚
â”‚                                                                                â”‚
â”‚     Cube sub_cube(1.0, Vector3D(0,0,0), 3);                                  â”‚
â”‚     std::cout << sub_cube.getFacets().size();    // Outputs: 324 (27Ã—12)     â”‚
â”‚                                                                                â”‚
â”‚     // Disable some subcells                                                  â”‚
â”‚     sub_cube.setSubCellActive(0, 0, 0, false);                                â”‚
â”‚     sub_cube.refreshTriangulation();                                           â”‚
â”‚     std::cout << sub_cube.getFacets().size();    // Outputs: 312 (26Ã—12)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PLANE-BASED FACETS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getPlaneFacets(int axis, int layer) const                             â”‚
â”‚ FacetBox getPlaneFacets(const std::string& coord1, coord2, coord3) const       â”‚
â”‚   Generate triangular faces for all subcells in a specific 2D plane.          â”‚
â”‚   â€¢ Useful for layer-by-layer rendering or analysis                           â”‚
â”‚   â€¢ Only includes triangular faces from active subcells in the plane          â”‚
â”‚   â€¢ Each active subcell in plane contributes 12 triangular faces              â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLES:                                                                     â”‚
â”‚     cube.subdivide(4);                                                         â”‚
â”‚     // Numeric interface                                                       â”‚
â”‚     FacetBox xy_plane = cube.getPlaneFacets(2, 2);     // Center XY plane     â”‚
â”‚     std::cout << xy_plane.size();  // 4Ã—4Ã—12 = 192 triangular faces          â”‚
â”‚                                                                                â”‚
â”‚     // String interface (more user-friendly)                                  â”‚
â”‚     FacetBox center_xy = cube.getPlaneFacets("x", "y", "0");                  â”‚
â”‚     FacetBox upper_xz = cube.getPlaneFacets("x", "1", "z");                   â”‚
â”‚                                                                                â”‚
â”‚     // Render planes with different colors                                    â”‚
â”‚     renderer.setColor(RED);                                                   â”‚
â”‚     renderer.drawFacets(center_xy);                                            â”‚
â”‚     renderer.setColor(BLUE);                                                  â”‚
â”‚     renderer.drawFacets(upper_xz);                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

PATTERN-BASED FACETS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ FacetBox getCheckerboardFacets() const                                         â”‚
â”‚   Generate triangular faces for subcells following checkerboard pattern.      â”‚
â”‚   â€¢ Selects ~25% of subcells in spatially distributed pattern                â”‚
â”‚   â€¢ Useful for performance testing and visual effects                         â”‚
â”‚   â€¢ Only includes triangular faces from active pattern subcells               â”‚
â”‚                                                                                 â”‚
â”‚   EXAMPLE:                                                                      â”‚
â”‚     cube.subdivide(8);                                                         â”‚
â”‚     FacetBox all_faces = cube.getFacets();                                    â”‚
â”‚     FacetBox checker_faces = cube.getCheckerboardFacets();                    â”‚
â”‚                                                                                â”‚
â”‚     std::cout << "Full: " << all_faces.size()                                 â”‚
â”‚               << ", Checkerboard: " << checker_faces.size() << std::endl;     â”‚
â”‚     // Outputs approximately: "Full: 6144, Checkerboard: 1536"               â”‚
â”‚                                                                                â”‚
â”‚     // Performance comparison                                                  â”‚
â”‚     auto t1 = std::chrono::high_resolution_clock::now();                      â”‚
â”‚     renderer.drawFacets(checker_faces);                                        â”‚
â”‚     auto t2 = std::chrono::high_resolution_clock::now();                      â”‚
â”‚     // Measure rendering time difference                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FACET COUNT CALCULATIONS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CUBE TYPE           â”‚ SUBCELLS    â”‚ FACES PER SUBCELL â”‚ TOTAL TRIANGULAR FACES â”‚ â”‚
â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚ Basic cube          â”‚ 1           â”‚ 12                â”‚ 12                     â”‚ â”‚
â”‚ subdivide(2)        â”‚ 2Â³ = 8      â”‚ 12                â”‚ 96                     â”‚ â”‚
â”‚ subdivide(3)        â”‚ 3Â³ = 27     â”‚ 12                â”‚ 324                    â”‚ â”‚
â”‚ subdivide(5)        â”‚ 5Â³ = 125    â”‚ 12                â”‚ 1,500                  â”‚ â”‚
â”‚ subdivide(10)       â”‚ 10Â³ = 1,000 â”‚ 12                â”‚ 12,000                 â”‚ â”‚
â”‚                                                                                 â”‚
â”‚ PLANE FACES (for nÃ—nÃ—n subdivision):                                          â”‚ â”‚
â”‚ â€¢ XY/XZ/YZ plane: nÂ² subcells Ã— 12 triangular faces = nÂ² Ã— 12                 â”‚ â”‚
â”‚ â€¢ Checkerboard: ~nÂ³/4 subcells Ã— 12 triangular faces = ~nÂ³ Ã— 3                â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

FACET STRUCTURE AND PROPERTIES:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Each Facet (triangular face) contains:                                        â”‚ â”‚
â”‚ â€¢ 3 vertices (Vector3D positions)                                             â”‚ â”‚
â”‚ â€¢ Automatically calculated normal vector                                       â”‚ â”‚
â”‚ â€¢ Consistent winding order for proper rendering                               â”‚ â”‚
â”‚                                                                                 â”‚
â”‚ FacetBox properties:                                                           â”‚ â”‚
â”‚ â€¢ Efficient storage of multiple triangular faces                              â”‚ â”‚
â”‚ â€¢ Iteratable container for rendering loops                                    â”‚ â”‚
â”‚ â€¢ Compatible with standard rendering pipelines                                 â”‚ â”‚
â”‚ â€¢ Supports batch operations and transformations                               â”‚ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

COMMON RENDERING WORKFLOWS:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. FULL CUBE RENDERING:                                                       â”‚
â”‚    FacetBox all_faces = cube.getFacets();                                     â”‚
â”‚    renderer.drawFacets(all_faces);                                             â”‚
â”‚                                                                                â”‚
â”‚ 2. LAYER-BY-LAYER ANIMATION:                                                  â”‚
â”‚    for (int z = -n/2; z < n/2; ++z) {                                         â”‚
â”‚      FacetBox layer = cube.getPlaneFacets("x", "y", std::to_string(z));       â”‚
â”‚      renderer.drawFacets(layer);                                               â”‚
â”‚      std::this_thread::sleep_for(std::chrono::milliseconds(100));             â”‚
â”‚    }                                                                           â”‚
â”‚                                                                                â”‚
â”‚ 3. SELECTIVE RENDERING:                                                       â”‚
â”‚    // Render only interesting subcells                                        â”‚
â”‚    for (auto [x,y,z] : interesting_coordinates) {                             â”‚
â”‚      if (cube.getSubCell(x,y,z).active) {                                     â”‚
â”‚        FacetBox cell_faces = cube.getSubCellFacets(x,y,z);                    â”‚
â”‚        renderer.setColor(getColorFor(x,y,z));                                 â”‚
â”‚        renderer.drawFacets(cell_faces);                                        â”‚
â”‚      }                                                                         â”‚
â”‚    }                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

)" << std::endl;
    }
    
    void showMethodHelp(const std::string& method_name) const {
        if (method_name == "faceCount") {
            std::cout << R"(
METHOD: size_t faceCount() const noexcept

DESCRIPTION:
  Returns the total number of triangular faces in the cube.

PARAMETERS:
  None

RETURN VALUE:
  size_t - Number of triangular faces
  â€¢ Basic cube: 12
  â€¢ Subdivided cube: nÂ³ Ã— 12 (where n = subdivision levels)

EXAMPLE:
  Cube cube(1.0, Vector3D(0,0,0));
  std::cout << cube.faceCount();        // Output: 12
  
  cube.subdivide(3);
  std::cout << cube.faceCount();        // Output: 324

NOTES:
  â€¢ noexcept guarantee - will never throw exceptions
  â€¢ O(1) constant time operation
  â€¢ Count reflects active subcells only
)" << std::endl;

        } else if (method_name == "center") {
            std::cout << R"(
METHOD: Vector3D center() const

DESCRIPTION:
  Calculate geometric center by averaging all vertex positions.

PARAMETERS:
  None

RETURN VALUE:
  Vector3D - The geometric center point

EXCEPTIONS:
  std::runtime_error - If no vertices have been initialized

EXAMPLE:
  Cube cube(2.0, Vector3D(5,3,1));
  Vector3D c = cube.center();           // c = (5,3,1)
  
  cube.translate(Vector3D(10,0,0));
  Vector3D new_c = cube.center();       // new_c = (15,3,1)

NOTES:
  â€¢ For basic cubes: matches original center parameter
  â€¢ For subdivided cubes: center of overall structure
  â€¢ Reflects any translations applied to the cube
)" << std::endl;

        } else if (method_name == "translate") {
            std::cout << R"(
METHOD: void translate(const Vector3D& offset)

DESCRIPTION:
  Move entire cube by adding offset to all vertex positions.

PARAMETERS:
  offset - Vector3D displacement to apply

RETURN VALUE:
  None (void)

SIDE EFFECTS:
  â€¢ Updates all vertex positions
  â€¢ Automatically rebuilds triangulation
  â€¢ Affects both main vertices and subdivision data

EXAMPLE:
  Cube cube(1.0, Vector3D(0,0,0));
  cube.translate(Vector3D(5,3,1));      // Move to (5,3,1)
  cube.translate(Vector3D(0,0,10));     // Move up by 10 units
  Vector3D final_pos = cube.center();   // final_pos = (5,3,11)

PERFORMANCE:
  O(nÂ³) for subdivided cubes due to triangulation rebuild
)" << std::endl;

        } else if (method_name == "scale") {
            std::cout << R"(
METHOD: void scale(double s, const Vector3D& pivot)

DESCRIPTION:
  Scale all vertices relative to a pivot point.

PARAMETERS:
  s     - Scaling factor (1.0=no change, >1.0=larger, <1.0=smaller)
  pivot - Fixed point that doesn't move during scaling

RETURN VALUE:
  None (void)

SIDE EFFECTS:
  â€¢ Updates all vertex positions
  â€¢ Automatically rebuilds triangulation

EXAMPLE:
  Cube cube(1.0, Vector3D(0,0,0));
  Vector3D center = cube.center();
  cube.scale(2.0, center);              // Double size around center
  cube.scale(0.5, Vector3D(0,0,0));     // Half size around origin

NOTES:
  â€¢ Scaling around cube center preserves center position
  â€¢ Scaling around origin moves cube toward/away from origin
)" << std::endl;

        } else if (method_name == "subdivide") {
            std::cout << R"(
METHOD: void subdivide(int n)

DESCRIPTION:
  Divide cube into nÃ—nÃ—n smaller subcubes with full triangulation.

PARAMETERS:
  n - Number of subdivisions per axis (must be > 0)

RETURN VALUE:
  None (void)

SIDE EFFECTS:
  â€¢ Creates nÂ³ subcubes in 3D grid
  â€¢ Replaces simple triangulation with complex subdivision
  â€¢ Sets hasSubdivision() to true
  â€¢ Updates faceCount() to nÂ³ Ã— 12

EXAMPLE:
  Cube cube(1.0, Vector3D(0,0,0));
  cube.subdivide(3);                    // Creates 27 subcubes
  assert(cube.hasSubdivision());        // Now true
  assert(cube.faceCount() == 324);      // 27 Ã— 12

PERFORMANCE:
  â€¢ Memory: O(nÂ³) for subcell storage
  â€¢ Time: O(nÂ³) for initial creation
  â€¢ Consider memory usage for large n values
)" << std::endl;

        } else if (method_name == "hasSubdivision") {
            std::cout << R"(
METHOD: bool hasSubdivision() const noexcept

DESCRIPTION:
  Check if subdivision has been performed and data is available.

PARAMETERS:
  None

RETURN VALUE:
  bool - true if subdivision exists and is accessible

EXAMPLE:
  Cube cube(1.0, Vector3D(0,0,0));
  if (!cube.hasSubdivision()) {         // Returns true - no subdivision
    cube.subdivide(3);
  }
  assert(cube.hasSubdivision());        // Now returns true

USAGE:
  ALWAYS check this before using subdivision-specific methods:
  â€¢ getSubCell(), getPlane(), updateSubCellVertex(), etc.
  â€¢ Prevents runtime errors from invalid subdivision access

NOTES:
  â€¢ noexcept guarantee - will never throw exceptions
  â€¢ Required guard for all subdivision operations
)" << std::endl;

        } else if (method_name == "getSubCell") {
            std::cout << R"(
METHOD: const SubCell& getSubCell(int x, int y, int z) const

DESCRIPTION:
  Access specific subcell using logical coordinates (user-friendly).

PARAMETERS:
  x - Logical X-coordinate (0=center, negative=left, positive=right)
  y - Logical Y-coordinate (0=center, negative=down, positive=up)  
  z - Logical Z-coordinate (0=center, negative=back, positive=front)

RETURN VALUE:
  const SubCell& - Reference to the specified subcell

EXCEPTIONS:
  std::out_of_range - If coordinates invalid or no subdivision

EXAMPLE:
  cube.subdivide(5);
  const SubCell& center = cube.getSubCell(0, 0, 0);    // Center
  const SubCell& corner = cube.getSubCell(2, 2, 2);    // Corner
  
  Vector3D pos = center.center;         // Access subcell properties
  double r = center.radius;
  bool active = center.active;

COORDINATE RANGES:
  Depends on subdivision level n:
  â€¢ n=3: x,y,z âˆˆ [-1, 1]
  â€¢ n=5: x,y,z âˆˆ [-2, 2]  
  â€¢ n=4: x,y,z âˆˆ [-2, 1] (asymmetric for even n)
)" << std::endl;

        } else if (method_name == "updateSubCellVertex") {
            std::cout << R"(
METHOD: void updateSubCellVertex(int x, int y, int z, int vertex_idx, 
                                const Vector3D& new_pos)

DESCRIPTION:
  Modify position of specific vertex within a subcell.

PARAMETERS:
  x,y,z      - Logical coordinates of target subcell
  vertex_idx - Vertex index [0,7] within the subcell
  new_pos    - New 3D position for the vertex

RETURN VALUE:
  None (void)

EXCEPTIONS:
  std::out_of_range - If coordinates or vertex_idx invalid

VERTEX INDICES:
  0: front-bottom-left     4: back-bottom-left
  1: front-bottom-right    5: back-bottom-right  
  2: front-top-right       6: back-top-right
  3: front-top-left        7: back-top-left

EXAMPLE:
  cube.subdivide(3);
  // Pull center subcell's top-right vertex upward
  Vector3D new_pos = Vector3D(1.5, 2.0, 1.5);
  cube.updateSubCellVertex(0, 0, 0, 2, new_pos);
  cube.refreshTriangulation();          // REQUIRED after changes

WORKFLOW:
  1. Make vertex modifications (can batch multiple updates)
  2. Call refreshTriangulation() once at end
  3. Changes reflected in getFacets(), getSubCellFacets(), etc.
)" << std::endl;

        } else if (method_name == "refreshTriangulation") {
            std::cout << R"(
METHOD: void refreshTriangulation()

DESCRIPTION:
  Rebuild all triangular faces after vertex modifications.

PARAMETERS:
  None

RETURN VALUE:
  None (void)

WHEN TO CALL:
  REQUIRED after any updateSubCellVertex() operations
  â€¢ Scans all active subcells
  â€¢ Regenerates 12 triangular faces per subcell
  â€¢ Updates internal facets collection

EXAMPLE:
  // Batch vertex updates for efficiency
  cube.updateSubCellVertex(0, 0, 0, 0, pos1);
  cube.updateSubCellVertex(0, 0, 0, 1, pos2);  
  cube.updateSubCellVertex(1, 1, 1, 3, pos3);
  // Single refresh for all changes
  cube.refreshTriangulation();

PERFORMANCE:
  â€¢ O(nÂ³) complexity where n = subdivision levels
  â€¢ Expensive for large subdivisions
  â€¢ Batch vertex updates to minimize calls

SIDE EFFECTS:
  â€¢ Updates getFacets() return value
  â€¢ Updates all facet generation methods
  â€¢ Skips inactive subcells automatically
)" << std::endl;

        } else if (method_name == "getPlane") {
            std::cout << R"(
METHOD: std::vector<std::reference_wrapper<const SubCell>> 
        getPlane(int axis, int layer) const

DESCRIPTION:
  Extract all subcells from a 2D plane within the 3D subdivision.

PARAMETERS:
  axis  - Plane orientation (0=YZ, 1=XZ, 2=XY)
  layer - Physical layer index [0, n) within the axis

RETURN VALUE:
  Vector of const references to subcells in the plane

EXCEPTIONS:
  std::out_of_range - If axis or layer invalid
  std::runtime_error - If no subdivision available

AXIS MEANINGS:
  0 (YZ plane): fixes X, varies Y and Z
  1 (XZ plane): fixes Y, varies X and Z  
  2 (XY plane): fixes Z, varies X and Y

EXAMPLE:
  cube.subdivide(5);
  // Get center XY plane (layer 2 for n=5)
  auto xy_plane = cube.getPlane(2, 2);
  std::cout << xy_plane.size();         // Output: 25 (5Ã—5)
  
  for (const SubCell& cell : xy_plane) {
    std::cout << cell.center << std::endl;
  }

LAYER CALCULATION:
  For logical coordinate L and subdivision n:
  Physical layer = n/2 + L
)" << std::endl;

        } else if (method_name == "getPlaneFacets") {
            std::cout << R"(
METHOD: FacetBox getPlaneFacets(int axis, int layer) const
        FacetBox getPlaneFacets(const std::string& coord1, coord2, coord3) const

DESCRIPTION:
  Generate triangular faces for all subcells in a 2D plane.

NUMERIC VERSION PARAMETERS:
  axis  - Plane orientation (0=YZ, 1=XZ, 2=XY)
  layer - Physical layer index [0, n)

STRING VERSION PARAMETERS:  
  coord1,coord2,coord3 - Two axis names ("x","y","z") + one numeric value

RETURN VALUE:
  FacetBox containing triangular faces from plane subcells

EXAMPLES:
  // Numeric interface
  FacetBox xy_faces = cube.getPlaneFacets(2, 2);     // Center XY plane
  
  // String interface (more intuitive)
  FacetBox center_xy = cube.getPlaneFacets("x", "y", "0");
  FacetBox upper_xz = cube.getPlaneFacets("x", "1", "z");
  FacetBox right_yz = cube.getPlaneFacets("2", "y", "z");

FACE COUNT:
  nÂ² subcells Ã— 12 triangular faces per subcell = nÂ² Ã— 12 total

USAGE:
  renderer.drawFacets(cube.getPlaneFacets("x", "y", "0"));
)" << std::endl;

        } else if (method_name == "getCheckerboardFacets") {
            std::cout << R"(
METHOD: FacetBox getCheckerboardFacets() const

DESCRIPTION:
  Generate triangular faces for subcells in 3D checkerboard pattern.

PARAMETERS:
  None

RETURN VALUE:
  FacetBox containing triangular faces from pattern subcells

PATTERN RULE:
  Selects subcells where (i+j+k) % 4 == 0 using physical coordinates
  Results in ~25% of subcells in spatially distributed pattern

EXAMPLE:
  cube.subdivide(8);
  FacetBox all_faces = cube.getFacets();            // All subcells
  FacetBox checker_faces = cube.getCheckerboardFacets(); // ~25% of subcells
  
  std::cout << "Reduction: " << checker_faces.size() 
            << "/" << all_faces.size() << std::endl;

USE CASES:
  â€¢ Performance testing with reduced geometry
  â€¢ Level-of-detail rendering for distant objects  
  â€¢ Visual effects with alternating patterns
  â€¢ Sampling and statistical analysis

PERFORMANCE:
  Roughly 4Ã— faster rendering due to 25% face count reduction
)" << std::endl;
        } else {
            std::cout << "âŒ No specific help available for method: " << method_name << std::endl;
        }
    }

This help system provides:
Key Features:

    Comprehensive Coverage: Every method, constructor, and concept explained
    Categorized Organization: Methods grouped by functionality (constructors, basic ops, subdivision, etc.)
    Usage Examples: Practical code examples for each method
    Visual Diagrams: ASCII art showing coordinate systems, patterns, and structures
    Error Guidance: Common exceptions and how to avoid them
    Performance Notes: Complexity analysis and optimization tips

Usage Examples:

// Get general help
cube.help();

// Get category help  
cube.help("constructors");
cube.help("subdivision");
cube.help("coordinates");

// Get specific method help
cube.help("subdivide");
cube.help("getSubCell");
cube.help("updateSubCellVertex");

// Case-insensitive and flexible
cube.help("SUBDIVISION");
cube.help("coords");
cube.help("facets");

